#include "Wire.h"
// requires I2Cdev library: https://github.com/jrowberg/i2cdevlib
#include "I2Cdev.h"

// requires MPU-6050 part of the I2Cdev lib: https://github.com/jrowberg/i2cdevlib/tree/master/Arduino/MPU6050
#include "MPU6050.h"

#include <JeeLib.h>
float IMU_smoothVal;

int ii;

// sensor
MPU6050 sensor;
int16_t ax, ay, az;
int16_t gx, gy, gz;
float gain;

// filtering
float v[9];
float currval, maxval, smoothval, mag;
uint32_t lastmax;



void setup () {
 Wire.begin();  
  Serial.begin(57600);
    Serial.println(57600);
    Serial.println("Send");
    rf12_initialize(1, RF12_868MHZ, 33);
    
    
    
  // initialize the filter
  for (ii=0; ii<9; ii++)
    v[ii] = 0.0;
  currval = 0.0;
  maxval = 0.0;
  smoothval = 0.0;
  lastmax = millis();

  // set up the MPU
  sensor.initialize();

  gain = 4.0; // higher -> more sensitive
}

void loop ()
{   



 // read mpu data
  sensor.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);

  // scale ax and feed to filter
  mag = step_filter(ax/3276.8);

  // find max value in current time window
  if (millis()-lastmax < 100)
  {
    if (fabs(mag) > maxval) maxval = fabs(mag);
  } 
  else {
    currval = maxval;
    maxval = 0.0;
    lastmax = millis();
  }

  // provide smoothing on value
  smoothval = 0.9*smoothval + 0.1*currval;


 
 


    // wait until we can send
    while (!rf12_canSend())
        rf12_recvDone();

    // send bytes starting at address of angle
    // with length sizeof angle (int)
    rf12_sendStart(0, &smoothval, sizeof smoothval);

    rf12_sendWait(1);

    // you probably want a delay or low-power sleep or something here



  // the delay is important
  // the loop will run at some rate, this rate determines the coefficients
  //  for the filter. I have measured the time it takes for the loop to
  //  complete and used this for calculating the coefs.
  delay(1);
  //Serial.print(smoothval);
}
// given a new value x, step the filter forward and return the newest filtered value
// code generated by http://www.schwietering.com/jayduino/filtuino/
// 4th order Butterwoth filter centered on 13 Hz
float step_filter (float x)
{
  v[0] = v[1];
  v[1] = v[2];
  v[2] = v[3];
  v[3] = v[4];
  v[4] = v[5];
  v[5] = v[6];
  v[6] = v[7];
  v[7] = v[8];
  v[8] = (4.392209311882e-5 * x)
    + ( -0.6378838221 * v[0])
      + (  5.1150034552 * v[1])
        + (-18.2346630494 * v[2])
          + ( 37.7215398561 * v[3])
            + (-49.5091483922 * v[4])
              + ( 42.2118284653 * v[5])
                + (-22.8337680359 * v[6])
                  + (  7.1670057953 * v[7]);

  return (v[0] + v[8]) - 4*(v[2] + v[6]) + 6*v[4];
}
